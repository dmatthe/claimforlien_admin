const runSequence = require('run-sequence');
const sass = require('gulp-sass');
const autoprefixer = require('gulp-autoprefixer');
const remoteSrc = require('gulp-remote-src');
const babel = require('gulp-babel');
const polyfill = require('babel-polyfill');
const rename = require('gulp-rename');
const useref = require('gulp-useref');
const gulpIf = require('gulp-if');
const uglify = require('gulp-uglify');
const cssnano = require('gulp-cssnano');
const htmlmin = require('gulp-htmlmin');
const cache = require('gulp-cache');
const notify = require('gulp-notify');
const imagemin = require('gulp-imagemin');
const inject = require('gulp-inject');
const injectString = require('gulp-inject-string');
const preprocess = require('gulp-preprocess');
const git = require('gulp-git');
const replace = require('gulp-replace');
const del = require('del');
const browserSync = require('browser-sync').create();
const env = require('node-env-file');
const fs = require("fs");
const tap = require('gulp-tap');
const zip = require('gulp-zip');
const mergeStreams = require('merge-stream');
const deleteLines = require('gulp-delete-lines');

/*
 See src/scaffolding/sample_gulpfile.js for how to use this file
 */
const GulpHelper = {
  embeddedApp: {
    /*
    createTasks
    This creates all the gulp tasks you need to build, run, and deploy a corejs app.

    gulp: your gulp instance
    options: a javascript key/value pair object. see initializer below for documentation
     */

    createTasks: (gulp, options) => {
      options = Object.assign({
        pkg: null, //Required for release task. the app's package.json file as a javascript object. when specified, appName and config can be omitted
        appName: (options['pkg'] || {})['name'], //Required unless pkg is specified. The name of the app. This is used to create build and distribution folders.
        config: (options['pkg'] || {})['coreConfig'], //Required unless pkg is specified. The coreConfig options from the app's package.json
        embedArea: 'full', //Optional. Only applies to embedded apps. Indicates where this app should be embedded in the simulator: 'full', 'left', or 'right'
        environmentOverride: null, //Optional, set to 'local', 'dev', 'qa', or 'prod' to force a build for a specified environment
        deploymentPath: '', //By default, standalone apps are built to deploy to /webapps/appname, but you can use this option to override that value. Note this should NOT end with a slash. ex: /webapps/work/decom/appname
        preprocessorContext: {}
        /*
         Developers can use the preprocessorContext option to add to the preprocessor context
         They can add environment specific items or generic items.
         ex:
         core.embeddedApp.createTasks(gulp, {
           ...
           preprocessorContext: {
             local: {
             ... these vars will only be in the context in the local environment ...
             },
             dev: {
             ... these vars will only be in the context in the local environment ...
             }
             OTHER: 'this var will be in the context of any environment'
           }
           ...
         });
         */
      }, options);

      if (!options['config'] || !options['appName']) {
        throw new Error('config and appName are both required for createTasks options');
      }

      let QA_RELEASE = (options.pkg || {})['qaRelease'];
      let VERSION = (options.pkg || {})['version'];
      let isEmbeddedApp = options['config']['isEmbedded'];
      let includeWebtrends = options['config']['includeWebtrends'];
      let isInternetStandaloneApp = options['config']['isInternetStandaloneApp'];
      let deploymentPath = isEmbeddedApp ? `/resources/${options['appName']}` : (options['deploymentPath'] || `/webapps/${options['appName']}`);

      //load env variables
      try {
        env('./.env');
      } catch (err) {
        process.stdout.write('Warning!!: no .env file found\n');
      }

      //what is the deployment environment?
      let deployment_environment = options['environmentOverride'] || 'local';

      function preprocessorOptions() {
        /*
         Core uses https://www.npmjs.com/package/gulp-preprocess to allow for preprocessing

         See https://github.com/jsoverson/preprocess#directive-syntax for more about preprocessor syntax

         ex:
         // @if ENV='local' || ENV='dev'
         console.log('running on local or dev');
         // @endif

         Any variables inside your .env file will be available to preprocessor statements
         Available preprocessor variables:

         ENV
         //the current build environment: local, dev, qa, or prod

         SRC_PATH
         //the deployment path of your project, ex: /resources/app_name

         QA_RELEASE
         //the current QA release value (from package.json)

         VERSION
         //the current version value from package.json

         IS_EMBEDDED
         //a boolean indicating if the current app is embedded or not

         INCLUDE_WEBTRENDS
         // URL of webtrend code to include || false
         // if set, code will be embedded in cFrame.html

         BUILD_ID
         //A unique ID for the current build

         startBuildTagWithCacheBuster
         //A helper method used in app.html, see usage/documentation there and below

         CC.<SECURE or NONSECURE>.<INTER or INTRA>.<PROTOCOL or HOSTNAME or PATHNAME or ORIGIN or HREF>
         //use this to get common component url information for the current environment
         //ex: CC.SECURE.INTER.ORIGIN will return https://was-inter-sit.toronto.ca for the 'dev' environment
         //ex: CC.SECURE.INTRA.HREF will return https://was-intra-sit.toronto.ca/cc_sr_admin_v1/ for the 'dev' env
         */
        let env = deployment_environment;
        let wpBaseTemplateUrl = (env === 'dev' || env === 'local') ? 'https://delivery0.cf.wp.inter.dev-toronto.ca'
        :   (env === 'qa' ? 'https://delivery0.cf.wp.inter.qa-toronto.ca'
        : 'https://www.toronto.ca');
        let qaRelease = QA_RELEASE === undefined ? 'unavailable' : QA_RELEASE;
        let version = VERSION || 'unavailable';
        let BUILD_ID = new Date();
        BUILD_ID = [BUILD_ID.getFullYear(),BUILD_ID.getMonth()+1, BUILD_ID.getDate(), BUILD_ID.getHours(), BUILD_ID.getMinutes(), BUILD_ID.getSeconds()].join('-');
        // noinspection JSUnusedGlobalSymbols
        let opt = {
          context: {
            WP_BASE_TEMPLATE_URL: wpBaseTemplateUrl,
            ENV: env,
            SRC_PATH: deploymentPath,
            QA_RELEASE: qaRelease,
            VERSION: version,
            IS_EMBEDDED: isEmbeddedApp,
            INCLUDE_WEBTRENDS:(function(){
              if (!isEmbeddedApp && includeWebtrends){
                if(env=='qa'){
                  return isInternetStandaloneApp
                    ?'https://delivery0.cf.wp.inter.qa-toronto.ca/scripts/qa-webtrends-infinity.load.js'
                    :'https://was-intra-qa.toronto.ca/web-analytics/qa-webtrends-infinity.load.js';
                }
                else if(env=='prod'){
                  return isInternetStandaloneApp
                  ?'https://www.toronto.ca/scripts/webtrends-infinity.load.js'
                  :'https://insideto-secure.toronto.ca/web-analytics/intra-webtrends-infinity.load.js';
                }
                else{
                  return isInternetStandaloneApp
                  ?'https://delivery0.cf.wp.inter.dev-toronto.ca/scripts/dev-webtrends-infinity.load.js'
                  :'https://was-intra-sit.toronto.ca/web-analytics/dev-webtrends-infinity.load.js';
                }
              }
              else return false;
            })(),
            BUILD_ID,
            startBuildTagWithCacheBuster: function (file, params) {
              //file: Required. The name of the file to build. ex: 'scripts/main.css'
              //params: Optional. Additional params to go in file tag. ex: 'media="print"'
              let ext = file.split('.')[1];
              let path = file.split('.')[0];
              let cacheBust = env === 'prod' ? version : env === 'qa' ? qaRelease : env === 'dev' ? Math.random().toString().split('.')[1] : '';
              return `<!-- build:${ext} ${deploymentPath}/${path}${cacheBust}.${ext} ${params || ''} -->`;
            },
            CC: {
              SECURE: {
                INTER: GulpHelper.commonComponentLocation({env, secure: true, network: 'inter'}),
                INTRA: GulpHelper.commonComponentLocation({env, secure: true, network: 'intra'})
              },
              NONSECURE: {
                INTER: GulpHelper.commonComponentLocation({env, secure: false, network: 'inter'}),
                INTRA: GulpHelper.commonComponentLocation({env, secure: false, network: 'intra'})
              }
            }
          }
        };

        if (options['preprocessorContext']) { //add user-defined options to the corejs created context
          for(let name in options['preprocessorContext']) {
            if (options['preprocessorContext'].hasOwnProperty(name)) {
              if (['local', 'dev', 'qa', 'prod'].indexOf(name) === -1) {
                opt.context[name] = options['preprocessorContext'][name];
              } else if (name === env) {
                Object.assign(opt.context, options['preprocessorContext'][name]);
              }
            }
          }
        }
        return opt;
      }

      let compress = false; //determines if files are minified, this is set to true in deploy tasks

      gulp.task('default', () => {
        return new Promise(resolve => {
          runSequence.use(gulp);
          runSequence('clean', 'build', resolve);
        });
      });

      //a task to remove the temp and dist directories
      gulp.task('clean', () => {
        del.sync(['.tmp', 'dist']);
      });

      //a task to build the project and create the distribution folder
      gulp.task('build', ['_html_styles_scripts', '_images', '_fonts', '_extras', '_bower_extras', '_data']);

      gulp.task('build_with_simulator', ['build'], () => {
        function processSimulatorSrc(stream) {
          let appHtml = gulp.src(['dist' + deploymentPath + '/html/app.html']);

          function between(string, start, end) {
            let x = string.indexOf(start);
            if (x > -1) {
              //noinspection JSUnresolvedFunction
              string = string.substring(x + start.length);
              let y = string.indexOf(end);
              if (y > -1) {
                //noinspection JSUnresolvedFunction
                return string.substring(0, y);
              }
            }
            return '';
          }

          return stream.pipe(rename((path) => {
            if (path.extname === '.html' || path.basename === 'cframe') {
              path.basename = 'index';
              path.extname = '.html'
            }
          }))
            .pipe(inject(appHtml, {
              starttag: '<!-- cot_app_injection:head -->',
              endtag: '<!-- end_cot_app_injection -->',
              transform: function (filePath, file) {
                return between(file.contents.toString('utf8'), '<!-- cot-app:head -->', '<!-- cot-app:head end-->');
              }
            }))
            .pipe(inject(appHtml, {
              starttag: '<!-- CONTENT -->',
              endtag: '</div>',
              transform: function (filePath, file) {
                let body = between(file.contents.toString('utf8'), '<!-- cot-app:body -->', '<!-- cot-app:body end-->');
                if (!isEmbeddedApp) {
                  return body;
                } else {
                  let html = '<div class="page-header"><h1>' + options['appName'] + ' Simulator</h1></div>';
                  switch (options['embedArea']) {
                    case 'left':
                      html += '<div class="row"><div id="page-content" class="col-md-8 col-lg-9">' + body + '</div>';
                      html += '<aside class="col-md-4 col-lg-3"></aside></div>';
                      break;
                    case 'right':
                      html += '<div class="row"><div id="page-content" class="col-md-8 col-lg-9"></div>';
                      html += '<aside class="col-md-4 col-lg-3">' + body + '</aside></div>';
                      break;
                    default:
                      html += '<div class="row"><div id="page-content" class="col-xs-12">' + body + '</div></div>';
                  }
                  return html;
                }
              }
            }))
            .pipe(inject(appHtml, {
              starttag: '<!-- cot_app_injection:footer -->',
              endtag: '<!-- end_cot_app_injection -->',
              transform: function (filePath, file) {
                return between(file.contents.toString('utf8'), '<!-- cot-app:footer -->', '<!-- cot-app:footer end-->');
              }
            }))
            .pipe(gulp.dest('dist'));
        }

        function staticStream() {
          let src;
          if (options['config']['isEmbedded'] === false && options['config']['isInternetStandaloneApp'] === false) {
            src = fs.existsSync('cframe.html') ? 'cframe.html' : '../../dist/html/cframe_intranet.html';
          } else {
            src = fs.existsSync('cframe.html') ? 'cframe.html' : '../../dist/html/cframe.html';
          }

          return GulpHelper.inject(gulp, inject, gulp.src(src), Object.assign(options['config'], {environment:deployment_environment}))
            .pipe(preprocess(preprocessorOptions()))
            .pipe(useref({newLine: '\n\n', searchPath: ['.']}))
            .pipe(gulpIf(compress, gulpIf('*.html', htmlmin({collapseWhitespace: false}))));
        }

        return processSimulatorSrc(!isEmbeddedApp ? staticStream() : remoteSrc(['cframe/'], {
          base: 'https://delivery0.cf.wp.inter.dev-toronto.ca/globalnav/',
          buffer: true,
          requestOptions: {
            proxy: process.env['PROXY'] || 'http://proxy.toronto.ca:8080'
          }
        }).on('error', function (e) {
          process.stdout.write('Error loading cframe: ' + e.toString() + '\nUsing barebones default simulator instead\n');
          gulp.src('../../node_modules/bootstrap/fonts/*.*').pipe(gulp.dest('dist/fonts')); //In this default sim, BS looks for the font files at /fonts...

          processSimulatorSrc(gulp.src('../../dist/html/default_simulator.html')
            .pipe(useref({newLine: '\n\n', searchPath: ['.']})));
          //noinspection JSUnresolvedFunction
          this.emit('end');
        }));
      });

      gulp.task('build_standalone', ['build_with_simulator'], () => {
        del.sync('dist' + deploymentPath + '/html/app.html', {force: true});
        return gulp.src('dist/index.html')
          .pipe(gulp.dest('dist' + deploymentPath));
      });

      gulp.task('run', () => {
        return new Promise(resolve => {
          runSequence('clean', 'build_with_simulator', '_serve', resolve);
        });
      });

      function copyToNetshare(env){
        let path = process.env['NETSHARE_DRIVE'];
        if (path) {
          path += `/web/content/${env || 'DEV'}${deploymentPath}`;
          process.stdout.write('Deleting existing app at ' + path + '\n');
          del.sync(path, {force: true});
          process.stdout.write('Copying app to ' + path + '.\n');
          if (env === 'STAGE4PROD') {
            process.stdout.write('App will be ready for double rsync to s3 production.\n');
          } else {
            process.stdout.write('rsync should move these changes to s3 within a few minutes.\n');
          }
          return gulp.src('dist' + deploymentPath + '/**/*.*')
            .pipe(gulp.dest(path));
        } else {
          process.stdout.write('Files are ready in dist' + deploymentPath + '.\n');
          process.stdout.write(`Please copy to \\\\netshare.toronto.ca\\inet\\web\\content\\${env || 'DEV'}\\resources\\${options['appName']}\n`);
          process.stdout.write('To have this copied automatically next time, do the following:\n');
          process.stdout.write('1. Make sure you have mapped \\\\netshare.toronto.ca\\inet as a network drive on your computer\n');
          process.stdout.write('2. Make sure that you have a .env file in your project (should be in the root folder)\n');
          process.stdout.write('3. Insert the following line into your .env file: NETSHARE_DRIVE=??\n');
          process.stdout.write('4. Replace the ?? with the mapped drive letter and colon, ex: NETSHARE_DRIVE=z:\n');
          process.stdout.write('4.1 Note that on a Mac, this looks different. Something like: NETSHARE_DRIVE=/Volumes/inet \n');
        }
      }
      gulp.task('deploy:dev', ['_deploy_prep:dev'], () => {
        try {
          if (isEmbeddedApp) {
            return copyToNetshare('DEV');
          } else {
            let path = process.env['DEV_DEPLOY_PATH'];
            if (path) {
              del.sync(path, {force: true});
              process.stdout.write('Deploying to ' + path + '\n');
              return gulp.src('dist' + deploymentPath + '/**/*.*')
                .pipe(gulp.dest(path));
            } else {
              process.stdout.write('Files are ready in dist' + deploymentPath + '.\n');
              process.stdout.write(`You must now copy these files to your distribution environment.\n`);
              process.stdout.write('To have this copied automatically next time, do the following:\n');
              process.stdout.write('1. Make sure that you have a .env file in your project (should be in the root folder)\n');
              process.stdout.write('2. Insert the following line into your .env file: DEV_DEPLOY_PATH=??\n');
              process.stdout.write('3. Replace the ?? with a directory path to copy your dev distribution to.\n');
              process.stdout.write('3.1 Example: DEV_DEPLOY_PATH=z:\\some\\deployment\\path \n');
            }
          }
        } catch(e) {
          process.stdout.write('An error occurred: \n' + e.toString());
        }
      });

      function zipAndCopy(envVar){
        process.stdout.write('Packaging and zipping files.\n');
        let path = process.env[envVar];
        if (!path) {
          path = 'dist';
          process.stdout.write('The ZIP file will be place in dist, do with it what you will.\n');
          process.stdout.write('To have this copied somewhere automatically next time, do the following:\n');
          process.stdout.write('1. Make sure that you have a .env file in your project (should be in the root folder)\n');
          process.stdout.write(`2. Insert the following line into your .env file: ${envVar}=??\n`);
          process.stdout.write('3. Replace the ?? with a directory path to copy the ZIP file to.\n');
          process.stdout.write(`3.1 Example: ${envVar}=z:\\some\\deployment\\path \n`);
        } else {
          process.stdout.write('The ZIP file will be place in ' + path + ', do with it what you will.\n');
        }
        let now = new Date();
        let fileName = `${options['appName']}_${envVar.substring(0,envVar.lastIndexOf('_'))}_${now.getFullYear()}_${("0" + (now.getMonth() + 1)).slice(-2)}_${now.getDate()}_${("0" + now.getHours()).slice(-2)}${("0" + now.getMinutes()).slice(-2)}.zip`;
        return gulp.src('dist' + deploymentPath + '/**/*.*')
          .pipe(tap(function (file) {
            if (file.isDirectory()) {
              file.stat.mode = parseInt('40777', 8); //fix directory permissions when running on windows
            }
          }))
          .pipe(zip(fileName))
          .pipe(gulp.dest(path));
      }

      gulp.task('deploy:qa', ['_deploy_prep:qa'], () => {
        try {
          if (isEmbeddedApp) {
            return copyToNetshare('QA');
          } else {
            return zipAndCopy('QA_DEPLOY_PATH');
          }
        } catch(e) {
          process.stdout.write('An error occurred: \n' + e.toString());
        }
      });

      gulp.task('deploy:prod', ['_deploy_prep:prod'], () => {
        try {
          if (isEmbeddedApp) {
            return copyToNetshare('STAGE4PROD');
          } else {
            return zipAndCopy('PROD_DEPLOY_PATH');
          }
        } catch(e) {
          process.stdout.write('An error occurred: \n' + e.toString());
        }
      });

      gulp.task('release', () => {
        process.stdout.write('checking working copy for changes...\n');
        return git.status({args : '--porcelain'}, function (err, stdout) {
          if (stdout) {
            throw new Error('You cannot proceed until your working copy is clean!');
          } else {
            process.stdout.write('Working copy ok, proceeding\n');
            if (!options.pkg) {
              throw new Error('To use the release task, you must pass in the pkg option to gulp_helper#embeddedApp.createTasks');
            }
            let prod = process.argv.indexOf('--prod') > -1 ? 1 : 0;
            let qa = process.argv.indexOf('--qa') > -1 ? 1 : 0;
            if (prod + qa !== 1) {
              throw new Error('Invalid arguments, specify --qa or --prod\n');
            }
            let deployTask = `deploy:${prod ? 'prod' : 'qa'}`;
            return new Promise(resolve => {
              runSequence('_increment_release_number', deployTask, '_tag_release', resolve);
            });
          }
        });
      });

      gulp.task('_increment_release_number', () => {
        let qa = process.argv.indexOf('--qa') > -1 ? 1 : 0;
        if (qa) {
          let oldNumber = QA_RELEASE || 0;
          let propString = `"qaRelease": ${oldNumber},`;
          if(fs.readFileSync('./package.json', 'utf8').indexOf(propString) === -1) {
            throw new Error(`The qaRelease property in your package.json file is missing or has bad whitespace. It should look like: ${propString}`);
          }
          QA_RELEASE = oldNumber + 1;
          process.stdout.write(`Updating qaRelease from ${oldNumber} to ${QA_RELEASE}\n`);
          return gulp.src('./package.json')
            .pipe(replace(propString, `"qaRelease": ${QA_RELEASE},`))
            .pipe(gulp.dest('./'))
            .pipe(git.commit(`Updated qaRelease property to ${QA_RELEASE}`));
        } else {
          let major = process.argv.indexOf('--major') > -1 ? 1 : 0;
          let minor = process.argv.indexOf('--minor') > -1 ? 1 : 0;
          let patch = process.argv.indexOf('--patch') > -1 ? 1 : 0;
          if (major + minor + patch !== 1) {
            throw new Error('Invalid arguments, specify --major or --minor or --patch');
          }
          let oldVersion = VERSION || 'x.x.x';
          let propString = `"version": "${oldVersion}",`;
          if(fs.readFileSync('./package.json', 'utf8').indexOf(propString) === -1) {
            throw new Error(`The version property in your package.json file is missing or has bad whitespace. It should look like: ${propString}`);
          }
          let a = oldVersion.split('.');
          let i = major ? 0 : minor ? 1 : 2;
          a[i] = (parseInt(a[i]) + 1).toString();
          while (++i < 3) {
            a[i] = '0';
          }
          VERSION = a.join('.');
          process.stdout.write(`Updating version from ${oldVersion} to ${VERSION}\n`);
          return gulp.src('./package.json')
            .pipe(replace(propString, `"version": "${VERSION}",`))
            .pipe(gulp.dest('./'))
            .pipe(git.commit(`Updated version property to ${VERSION}`));
        }
      });

      gulp.task('_tag_release', () => {
        let prod = process.argv.indexOf('--prod') > -1 ? 1 : 0;
        let qa = process.argv.indexOf('--qa') > -1 ? 1 : 0;
        if (prod + qa !== 1) {
          throw new Error('Invalid arguments, specify --qa or --prod\n');
        }
        let tag = prod ? 'r' + VERSION : 'qa' + QA_RELEASE;
        let comment = prod ? 'Release ' + VERSION : 'QA Release ' + QA_RELEASE;
        git.tag(tag, comment, function (err) {
          if (err) throw err;
        });
        process.stdout.write(`HEY! Don't forget to push this release to your git repo!!!:\n\ngit push && git push --tags\n\n`);
      });

      //preprocess syntax: https://github.com/jsoverson/preprocess#directive-syntax
      gulp.task('_html_styles_scripts', ['_styles', '_scripts'], () => {
        return GulpHelper.inject(gulp, inject, gulp.src(['src/*.html']), Object.assign(options['config'], {environment:deployment_environment}))
          .pipe(preprocess(preprocessorOptions()))
          .pipe(useref({newLine: '\n', searchPath: ['.tmp', 'src', '.']}))
          .pipe(gulpIf(compress, gulpIf('*.js', uglify())))
          .pipe(gulpIf(compress, gulpIf('*.css', cssnano({safe: true}))))
          .pipe(gulpIf(compress, gulpIf('*.html', htmlmin({collapseWhitespace: false}))))
          .pipe(injectString.before('<div id="'+options['appName']+'_container">','<div class="js-aria-live sr-only" role="status" aria-live="polite"></div>'))
          .pipe(rename((path) => {
            if (path.extname === '.html') {
              path.dirname = deploymentPath.substr(1) + '/html';
            }
          }))
          .pipe(deleteLines({
            'filters': [
            /\/\/# sourceMappingURL(.*)/i
            ]
          }))
          .pipe(gulp.dest('dist'));
      });

      gulp.task('_styles', () => {
        //noinspection JSUnresolvedVariable
        return gulp.src('src/styles/**/*.scss')
          .pipe(preprocess(preprocessorOptions()))
          .pipe(sass.sync({
            outputStyle: 'expanded',
            precision: 10,
            includePaths: ['.']
          }).on('error', sass.logError))
          .pipe(autoprefixer({browsers: ['> 2% in CA', 'last 2 versions']}))
          .pipe(gulp.dest('.tmp' + deploymentPath + '/styles'));
      });

      gulp.task('_scripts', () => {
        return gulp.src('src/scripts/**/*.js')
          .pipe(preprocess(preprocessorOptions()))
          .pipe(babel({presets: [['env',{targets:{browsers:['> 2% in CA','last 2 versions']}}]]})).on("error", notify.onError(function (error) {
            let msg = error.message;
            if (msg.indexOf('Couldn\'t find preset "env"') > -1) {
              msg += '\n\n!!!!!\nMake sure you\'ve installed the babel-preset-env npm package with: npm install babel-preset-env --save-dev\n!!!!!\n\n';
            }
            return msg;
          }))
          .pipe(gulp.dest('.tmp' + deploymentPath + '/scripts'));
      });

      gulp.task('_images', () => {
        return gulp.src(['src/img/**/*'])
          .pipe(gulpIf(compress, cache(imagemin())))
          .pipe(gulp.dest('dist' + deploymentPath + '/img'));
      });

      gulp.task('_fonts', () => {
        return gulp.src(['src/fonts/**/*'])
          .pipe(gulp.dest('dist' + deploymentPath + '/fonts'));
      });

      gulp.task('_data', () => {
        //override this in your project if you want to do extra stuff during the build task

        //FAKING DATA AND CONFIG FILES:
        //Some apps will load data and configurations from 'data' files, usually JSON.
        //The location of these files in Dev, QA, and Prod may vary:
        //- Could be in the S3 data bucket
        //- Could be in a custom Wordpress post
        //To 'fake' this when running your app locally, do the following:
        // 1. Put some sample data/config files into /src/data folder in the project
        // 2. Overwrite the _data gulp task to copy your data files into a file path that mimics the one on your web server:
        // gulp.task('_data', () => {
        //   let myDataPath = '/data'; //On S3, this will be something like /data/division/my_app
        //                             //On WP, this will be /api_content
        //   return gulp.src(['src/data/**/*']).pipe(gulp.dest('dist' + myDataPath));
        // });
      });

      gulp.task('_extras', () => {
        return gulp.src([
          'src/*.*',
          '!src/*.html'
        ], {
          dot: true
        }).pipe(gulp.dest('dist' + deploymentPath));
      });

      gulp.task('_bower_extras', () => {
        return GulpHelper.distExtras(gulp, 'dist' + deploymentPath, options['config']);
      });

      gulp.task('_serve', () => {
        gulp.watch(['../../dist/fonts/**/*', 'src/fonts/**/*'], ['_fonts']);
        gulp.watch(['../../dist/img/**/*', 'src/img/**/*'], ['_images']);
        gulp.watch('src/data/**/*', ['_data']);
        gulp.watch(['src/*.*', '!src/*.html'], ['_extras']);
        gulp.watch(['../../dist/js/**/*.js', '../../dist/css/**/*.css', 'src/scripts/**/*.js', 'src/styles/**/*.scss'], ['_html_styles_scripts']);
        gulp.watch(['../../dist/html/**/*.html', 'src/*.html'], ['build_with_simulator']);
        browserSync.init({
          port: 9000,
          server: {
            baseDir: ['dist']
          }
        });
        //could get fancy here and use the stream method for things like CSS, to avoid reloading the whole page
        gulp.watch('dist/**/*').on('change', browserSync.reload);
      });

      //a task to clear the gulp-cache in case images get stuck in there
      gulp.task('_clear_image_cache', (done) => {
        return cache.clearAll(done);
      });

      function deployPrep(e, c) {
        deployment_environment = options['environmentOverride'] || e;
        compress = c;
        return new Promise(resolve => {
          runSequence('_clear_image_cache', 'clean', isEmbeddedApp ? 'build' : 'build_standalone', resolve);
        });
      }

      gulp.task('_deploy_prep:dev', () => {
        return deployPrep('dev', false);
      });

      gulp.task('_deploy_prep:qa', () => {
        return deployPrep('qa', true);
      });

      gulp.task('_deploy_prep:prod', () => {
        if (options['environmentOverride']) {
          process.stdout.write('\n\nWARNING! You are deploying to production with an environment override.\nThis is not allowed, and your override is being ignored.\n\n');
          options['environmentOverride'] = null; //do not allow environment overrides when deploying to production
        }

        return deployPrep('prod', true);
      });

    }
  },
  inject: (gulp, inject, stream, options) => {
    //gulp is your gulp object
    //inject is your gulp-inject object
    //stream is the result of a call to gulp.src
    //options is an object to specify what to inject
    //  see the 'coreConfig properties' section of package_settings.md for all the options here
    //  there is an extra one too: environment, which specifies the deployment environment, relates only to webtrends usage. String, can be one of: local, dev, qa, prod, internal, or external.

    if (options['isEmbedded']) { //some things are not allowed for embedded apps
      options['includeLogin'] = false;
      options['includeWebtrends'] = false;
    }

    let shivFiles = options['isEmbedded'] ? [] : [
      '../../node_modules/html5shiv/dist/html5shiv.js',
      '../../node_modules/respond/src/respond.js'
    ];

    let coreFiles = [
      '../../node_modules/js-cookie/src/js.cookie.js',
      '../../dist/js/jquery_ajax_datafilter.js'
    ];
    coreFiles = coreFiles.concat([ '../../dist/js/jquery.cookie.adapter.js'])

    let robotoFiles = options['isEmbedded'] ? [] : [
      '../../node_modules/roboto-fontface/css/roboto/roboto-fontface.css'
    ];
    let corePrintFiles = [];
    if (options['includeWebtrends']) {
      let env = options['environment'] || 'dev';
      if (env === 'local') {
        env = 'dev';
      } else if (env === 'prod') {
        if (options['isInternetStandaloneApp'] === true) {
          env = 'external';
        } else if (options['isInternetStandaloneApp'] === false) {
          env = 'internal';
        } else {
          throw new Error('When doing production builds for standalone apps with includeWebtrends set to true, you must also specify true or false for isInternetStandaloneApp');
        }
      }
      if (['external', 'internal', 'dev', 'qa'].indexOf(env) === -1) {
        throw new Error('Invalid webtrends environment specified: ' + env);
      }
    }

    process.stdout.write('Core gulp helper injecting (modified version) of Babel polyfill ^6.26.0\n');
    coreFiles = coreFiles.concat([
      '../../node_modules/core/dist/js/polyfill.js'
    ]);
    if(options['includeBootbox']){
      process.stdout.write('WARNING ! BOOTBOX IS DEPRECATED !\n');
      throw new Error('PLEASE UPDATE YOUR PROJECT - BOOTBOX DEPRECATED SINCE VERSION 9.0.0 - USE COT_MODAL INSTEAD')
    }
    if (options['includeModeling']) {
      process.stdout.write('Core gulp helper injecting underscore/backbone for modeling\n');
      coreFiles = coreFiles.concat([
        "../../node_modules/underscore/underscore.js",
        "../../node_modules/backbone/backbone.js",
        "../../dist/js/cot_backbone.js"
      ]);
    }
    if (options['includeIntlTelInput']) {
      process.stdout.write('Core gulp helper injecting intlTelInput\n');
      coreFiles = coreFiles.concat([
        "../../dist/js/intlTelInput.js",
        "../../node_modules/intl-tel-input/build/css/intlTelInput.css"
      ]);
    }
    if (options['includeJQueryMaskedInput']) {
      process.stdout.write('Core gulp helper injecting jquery.maskedinput.js\n');
      coreFiles = coreFiles.concat([
        "../../node_modules/jquery.maskedinput/dist/jquery.maskedinput.js",
      ]);
    }
    if (!options['isEmbedded']) {
      process.stdout.write('Core gulp helper injecting COTUI\n');
      coreFiles = coreFiles.concat([
        './node_modules/cotui/dist/cotui.min.css',
        './node_modules/cotui/dist/cotui.js'
      ]);
    }
    if (options['includeFormValidation']) {
      process.stdout.write('Core gulp helper injecting cot_forms and formValidation\n');
      coreFiles = coreFiles.concat([
        "../../dist/js/formValidation.min.js",
        "../../dist/js/cot_forms.js",
        "../../dist/css/formValidation.min.css",
      ]);
      if (options['isEmbedded'] || options['includeLogin']) {
        coreFiles = coreFiles.concat([
          '../../css/embedded_cot_forms.css'
        ]);
      }
    }
    if (options['includeEditableSelect']) {
      process.stdout.write('Core gulp helper injecting jquery-editable-select\n');
      coreFiles = coreFiles.concat([
        "../../node_modules/jquery-editable-select/dist/jquery-editable-select.js",
        "../../node_modules/jquery-editable-select/dist/jquery-editable-select.css"
      ]);
    }
    if (options['includePlaceholders']) {
      process.stdout.write('Core gulp helper injecting jquery placeholders\n');
      coreFiles = coreFiles.concat(['../../node_modules/placeholders/dist/placeholders.jquery.js']);
    }
    if (options['includeMultiSelect']) {
      process.stdout.write('Core gulp helper injecting bootstrap-multiselect\n');
      coreFiles = coreFiles.concat([
        '../../dist/js/lib/bootstrap-multiselect/dist/js/bootstrap-multiselect.js',
        '../../dist/js/cot_multiselect.js',
        '../../dist/css/bootstrap-multiselect.css'
      ]);
    }
    // if (options['includeOMS']) {
    //   process.stdout.write('Core gulp helper injecting OMS for google maps\n');
    //   coreFiles = coreFiles.concat(['./node_modules/core/dist/js/oms.min.js']);
    // }
    if (options['includeMoment'] || options['includeFullCalendar'] || options['includeDatePicker'] || options['includeRangePicker']) {
      process.stdout.write('Core gulp helper injecting momentjs\n');
      coreFiles = coreFiles.concat(['../../node_modules/moment/min/moment-with-locales.js']);
    }
    if (options['includeFullCalendar']) {
      process.stdout.write('Core gulp helper injecting fullcalendar\n');
      coreFiles = coreFiles.concat(['../../node_modules/fullcalendar/dist/fullcalendar.js']);
      coreFiles = coreFiles.concat(['../../node_modules/fullcalendar/dist/fullcalendar.css']);
      corePrintFiles = corePrintFiles.concat(['../../node_modules/fullcalendar/dist/fullcalendar.print.css']);
    }
    if (options['includeDatePicker']) {
      process.stdout.write('Core gulp helper injecting bootstrap-datetimepicker\n');
      coreFiles = coreFiles.concat([
        '../../node_modules/eonasdan-bootstrap-datetimepicker/build/js/bootstrap-datetimepicker.min.js',
        '../../node_modules/eonasdan-bootstrap-datetimepicker/build/css/bootstrap-datetimepicker.css'
      ]);
      // process.stdout.write('Core gulp helper injecting eureka2/ab-datepicker 123\n');
      // coreFiles = coreFiles.concat([
      //   '../../dist/js/lib/ab-datepicker-2.1.13/datepicker.js',
      //   '../../dist/js/lib/ab-datepicker-2.1.13/locales/en-CA.js',
      //   '../../dist/js/lib/ab-datepicker-2.1.13/locales/fr-CA.js'//,
      //   //'../../dist/css/datepicker.css'
      // ]);
      process.stdout.write('******** RUNNING : Remember to uncomment the ../../dist/css/datepicker.css ***********\n');

    }
    if (options['includeLogin']) {
      process.stdout.write('Core gulp helper injecting cot_login\n');
      coreFiles = coreFiles.concat(['../../dist/js/cot_login.js']);
    }
    if (options['includeRangePicker']) {
      process.stdout.write('Core gulp helper injecting daterangepicker\n');
      coreFiles = coreFiles.concat([
        '../../node_modules/bootstrap-daterangepicker/daterangepicker.js',
        '../../node_modules/bootstrap-daterangepicker/daterangepicker.css'
      ]);
    }
    if (options['includeDropzone']) {
      process.stdout.write('Core gulp helper injecting dropzone\n');
      coreFiles = coreFiles.concat([
        '../../node_modules/dropzone/dist/dropzone.js',
        '../../node_modules/dropzone/dist/dropzone.css',
        '../../dist/js/cot_dropzone.js',
        '../../dist/css/cot_dropzone.css'
      ]);
    }
    if (options['includeModal'] || options['includeLogin']) {
      process.stdout.write('Core gulp helper injecting cot_modal\n');
      coreFiles = coreFiles.concat([
        '../../dist/js/cot_modal.js',
      ]);
    }
    if (options['includeTerms']) {
      process.stdout.write('Core gulp helper injecting cot_terms\n');
      coreFiles = coreFiles.concat([
        '../../dist/js/cot_terms.js',
      ]);
    }
    if (options['includeMap']) {
      process.stdout.write('Core gulp helper injecting map\n');
      coreFiles = coreFiles.concat([
        '../../node_modules/leaflet/dist/leaflet.css',
        '../../node_modules/leaflet.markercluster/dist/MarkerCluster.Default.css',
        '../../node_modules/leaflet.fullscreen/Control.FullScreen.css',
        '../../dist/css/cot_map.css',
        '../../node_modules/leaflet/dist/leaflet.js',
        '../../node_modules/esri-leaflet/dist/esri-leaflet-debug.js',
        '../../node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js',
        '../../dist/js/lib/esri-leaflet-vector/esri-leaflet-vector-debug.js',
        '../../node_modules/esri-leaflet-cluster/dist/esri-leaflet-cluster-debug.js',
        '../../node_modules/leaflet.fullscreen/Control.FullScreen.js',
        '../../dist/js/cot_map.js'
      ]);
    }


    if (options['isEmbedded']) {
      coreFiles = coreFiles.concat([
        '../../dist/js/embedded_cot_app.js'
      ]);
    } else {
      coreFiles = coreFiles.concat([
        '../../dist/js/cot_app.js',
        '../../dist/css/cot_app.css'
      ]);
    }

    coreFiles = coreFiles.concat(['../../dist/css/cot_dropzone.css']);

    return stream
      .pipe(inject(gulp.src(shivFiles, {read: false}), {name: 'shiv', relative: false}))
      .pipe(inject(gulp.src(coreFiles, {read: false}), {name: 'core', relative: false}))
      .pipe(inject(gulp.src(robotoFiles, {read: false}), {name: 'roboto', relative: false}))
      .pipe(inject(gulp.src(corePrintFiles, {read: false}), {
        name: 'core_print',
        relative: false,
        transform: function (filePath) {
          if (filePath.slice(-4) === '.css') {
            return '<link rel="stylesheet" type="text/css" media="print" href="' + filePath + '">';
          }
          // Use the default transform as fallback:
          return inject.transform.apply(inject.transform, arguments);
        }
      }));
  },
  distExtras: (gulp, distDir, options) => {
    //gulp is your gulp object
    //distDir is your distribution directory
    //options is the same as the inject method above

    let streams = [];
    //bootstrap needs font files:
    if (!options['isEmbedded']) {
      streams.push(gulp.src(['../../node_modules/bootstrap/dist/fonts/*']).pipe(gulp.dest(distDir + '/fonts')));
    }

    if (!options['isEmbedded']) {
      //Roboto needs font files:
      streams.push(gulp.src(['../../node_modules/roboto-fontface/fonts/Roboto/*']).pipe(gulp.dest(distDir + '/fonts/Roboto')));
    }
    //core and intl-tel-input need images:
    let imageSrcs = options['isEmbedded'] ? [] : ['../../dist/img/*'];
    if (options['includeIntlTelInput']) {
      imageSrcs.push('../../node_modules/intl-tel-input/build/img/*');
    }
    if (imageSrcs.length > 0) {
      streams.push(gulp.src(imageSrcs).pipe(gulp.dest(distDir + '/img')));
    }

    // leafletJS as well !
    if (options['includeMap']) {
      streams.push(gulp.src('../../node_modules/leaflet/dist/images/*').pipe(gulp.dest(distDir + '/styles/images')));
    }

    //intl-tel-input needs a weird lib build folder with a js util referenced by the core
    if (options['includeIntlTelInput']) {
      streams.push(gulp.src('../../node_modules/intl-tel-input/build/js/utils.js')
        .pipe(gulp.dest(distDir + '/js')));
    }

    return streams.length > 0 ? mergeStreams.apply(null, streams) : false;
  },
  commonComponentLocation: (o) => {

    //the server environment to use: 'dev', 'qa', 'prod'
    let env = o['env'] || 'dev';
    if (env === 'local') {
      env = 'dev'; //treat local like dev when creating URLs
    }

    //whether to use internal (intranet) or external (internet) server: 'intra', 'inter'
    let network = o['network'] || 'intra';

    //whether to use HTTPS or not, boolean, default true
    let secure = o.hasOwnProperty('secure') ? !!o['secure'] : true;

    //the name of the CC Api to use: 'session', 'submit', 'upload', 'data', 'retrieve', 'retrieve/eventrepo'
    let api = o['api'];

    //the name of the CC app, string
    let app = o['app'];

    //a hash of querystring parameters
    let searchParams = o['searchParams'] || {};

    let protocol = secure ? 'https:' : 'http:';

    let hostname = {
        inter: {
          dev: 'was-inter-sit',
          qa: 'was-inter-qa',
          prod: secure ? 'secure' : 'app'
        },
        intra: {
          dev: 'was-intra-sit',
          qa: 'was-intra-qa',
          prod: secure ? 'insideto-secure' : 'insideto'
        }
      }[network][env] + '.toronto.ca';

    let pathname = '/unknown/';
    if (network === 'inter') {
      pathname = secure ? '/cc_sr_v1/' : '/cc_sr_v1_app/';
    } else if (secure) {
      pathname = '/cc_sr_admin_v1/';
    }
    pathname += (api ? api + '/' : '') + (api && app ? app : '');

    let params = [];
    for (let key in searchParams) {
      if (searchParams.hasOwnProperty(key)) {
        params.push(key + '=' + encodeURIComponent(searchParams[key]));
      }
    }
    let search = params.length === 0 ? '' : ('?' + params.join('&'));
    return {
      PROTOCOL: protocol,
      HOSTNAME: hostname,
      PATHNAME: pathname,
      SEARCH: search,
      ORIGIN: protocol + '//' + hostname,
      HREF: protocol + '//' + hostname + pathname + search
    }
  }
};
module.exports = GulpHelper;
