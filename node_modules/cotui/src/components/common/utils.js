const config = process.env;

/*
For IE11
Element.remove() is unsupported in Internet Explorer
https://github.com/developit/preact/issues/624#issuecomment-292131017
*/

(function() {
  function remove() { this.parentNode && this.parentNode.removeChild(this); }
  if (!Element.prototype.remove) Element.prototype.remove = remove;
  if (Text && !Text.prototype.remove) Text.prototype.remove = remove;
})();


/*
For IE11
PolyFill: NodeList.prototype.forEach()

https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach
The forEach() method of the NodeList interface calls the callback given in parameter once for each value pair in the list, in insertion order.
*/
if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
}


/*
For IE11
Polyfill
This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway:
*/
if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
      value: function assign(target, varArgs) { // .length of function is 2
        'use strict';
        if (target == null) { // TypeError if undefined or null
          throw new TypeError('Cannot convert undefined or null to object');
        }
  
        var to = Object(target);
  
        for (var index = 1; index < arguments.length; index++) {
          var nextSource = arguments[index];
  
          if (nextSource != null) { // Skip over if undefined or null
            for (var nextKey in nextSource) {
              // Avoid bugs when hasOwnProperty is shadowed
              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
        return to;
      },
      writable: true,
      configurable: true
    });
  }



  /* 
  *
  * IE11 PolyFill .closest()
  *
  */

 if (window.Element && !Element.prototype.closest) {
  Element.prototype.closest =
  function(s) {
    var matches = (this.document || this.ownerDocument).querySelectorAll(s),
        i,
        el = this;
    do {
      i = matches.length;
      while (--i >= 0 && matches.item(i) !== el) {};
    } while ((i < 0) && (el = el.parentElement));
    return el;
  };
}




String.prototype.capitalize = function() {
  return this.charAt(0).toUpperCase() + this.slice(1);
}
  


function keyCodes() {
  // Define values for keycodes
  this.tab = 9;
  this.enter = 13;
  this.esc = 27;

  this.space = 32;
  this.pageup = 33;
  this.pagedown = 34;
  this.end = 35;
  this.home = 36;

  this.left = 37;
  this.up = 38;
  this.right = 39;
  this.down = 40;

}



const slugify = (text)=>{
  return text.toString().toLowerCase()
    .replace(/\s+/g, '-')           // Replace spaces with -
    .replace(/[^\w\-]+/g, '')       // Remove all non-word chars
    .replace(/\-\-+/g, '-')         // Replace multiple - with single -
    .replace(/^-+/, '')             // Trim - from start of text
    .replace(/-+$/, '');            // Trim - from end of text
}

const URLSearchParams = (param) =>{
    const name = param.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
    var results = regex.exec(location.search);
    return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};

/* TODO: REPLACE ONLY {{BODY}} not containing element */
const getElementByText = ($els, searchText)=>{

  
  let found = '';
  for (var i = 1; i < $els.length; i++) {
    const regexp = new RegExp(searchText,'gi');
    if ($els[i].textContent.match(regexp)) {     
      $els[i].textContent = $els[i].textContent.replace(regexp,'');
      found = $els[i];
      break;
    }
  }
  return found;
}


const getURLParam = (param) =>{
  const name = param.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
  var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
  var results = regex.exec(location.search);
  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};

const StringOrBoolean = (value)=>{
  return ['true','false', true, false].indexOf(value) !== -1
}

const generateID = ()=> {
  return Math.random().toString(36).substr(2, 9)
}

const getJSON = (url)=>{

  return new Promise(function(resolve,reject){
      const request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.onload = function() {
          if (request.status >= 200 && request.status < 400) {
              // Success!
              const data = JSON.parse(request.responseText);
              resolve(data);
          } else {
              reject(new Error('Error:', request))
              // We reached our target server, but it returned an error
          }
      };
      request.onerror = function() {
      // There was a connection error of some sort
      };
      request.send();
  })
}

const getObjectFromString = (p, o) => p.reduce((xs, x) => (xs && xs[x]) ? xs[x] : null, o)


const updateAriaLive = function(msg){
  const ariaLive = document.querySelectorAll("[aria-live]")
  if(ariaLive){
    ariaLive.innerHTML = ''
    clearInterval(this.intervalID);
    this.intervalID = setInterval(()=>{
        ariaLive[0].innerHTML = msg
        clearInterval(this.intervalID)
    }, 1000)
  }
}



const closestHeader = function($el){
  let $closestEl = null;
  
  for(var i=0; i < 6; i++){
    if(!$closestEl){
     $closestEl = $el.closest(`h${i}`);
    } else {
      break;
    }
  }
  return $closestEl;
};


const replaceElement = function(node,to){
    const $el = document.createElement(to);
    Array.from(node.attributes).map((attr)=>{
      $el.setAttribute(attr.nodeName, attr.nodeValue)
    })
    $el.innerHTML = node.innerHTML;
    node.parentNode.replaceChild($el, node);
    node = $el;
  return node;
}

const delay = function(wait){ return new Promise((resolve) => setTimeout(resolve,wait))};


export default{
    slugify,
    StringOrBoolean,
    generateID,
    getJSON,
    getObjectFromString,
    updateAriaLive,
    URLSearchParams,
    getURLParam,
    getElementByText,
    closestHeader,
    replaceElement,
    delay
}